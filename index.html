<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Advanced Galactic Hand-Controlled Simulation</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000000; font-family: 'Segoe UI', sans-serif; }
        #canvas-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 1; }
        #ui-panel {
            position: absolute; top: 20px; right: 20px; z-index: 10;
            background: rgba(10, 10, 20, 0.85); backdrop-filter: blur(10px);
            padding: 20px; border-radius: 16px; border: 1px solid rgba(255,255,255,0.1);
            color: white; width: 260px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
        }
        h2 { margin: 0 0 15px 0; font-size: 18px; letter-spacing: 1px; text-transform: uppercase; color: #00ffff; }
        .status { margin-top: 15px; font-size: 12px; color: #00ff88; display: flex; align-items: center; gap: 8px;}
        .dot { width: 8px; height: 8px; background: #00ff88; border-radius: 50%; box-shadow: 0 0 10px #00ff88; }
        #hand-control-display {
            height: 10px; background: rgba(255,255,255,0.1); border-radius: 5px; margin-top: 10px;
        }
        #hand-control-bar {
            height: 100%; width: 50%; background: linear-gradient(90deg, #ff00ff, #00ffff);
            border-radius: 5px; transition: width 0.1s ease-out;
        }
        .mode-text { font-size: 14px; margin-top: 10px; color: #00ffff; }
        
        #loading {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: white; font-size: 24px; z-index: 20; pointer-events: none;
            text-shadow: 0 0 20px rgba(255,255,255,0.5);
        }
        #video-container {
            position: absolute; bottom: 20px; left: 20px; width: 240px; height: 180px;
            z-index: 2; border-radius: 12px; overflow: hidden; opacity: 0.2;
            box-shadow: 0 0 20px rgba(0,0,0,0.5); border: 2px solid rgba(255,255,255,0.1);
        }
        video { width: 100%; height: 100%; object-fit: cover; transform: scaleX(-1); }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
</head>
<body>

    <div id="loading">Initializing Advanced Vision System...</div>

    <div id="ui-panel">
        <h2>Galactic Control Center</h2>
        
        <div class="status">
            <div class="dot"></div>
            <span id="hand-status">Waiting for hands...</span>
        </div>
        
        <label style="margin-top: 10px;">Hand Tension (Zoom/Speed)</label>
        <div id="hand-control-display"><div id="hand-control-bar"></div></div>
        
        <div class="mode-text">Current Mode: <span id="mode-display">Solar System (Contracted)</span></div>
    </div>

    <div id="video-container">
        <video id="input-video"></video>
    </div>
    <div id="canvas-container"></div>

<script id="vertexshader" type="x-shader/x-vertex">
    uniform float size;
    uniform float scale;
    attribute vec3 customColor;
    attribute float particleLifetime;
    varying vec3 vColor;
    
    void main() {
        vColor = customColor;
        vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );
        gl_PointSize = size * ( 1.0 / - mvPosition.z );
        gl_Position = projectionMatrix * mvPosition;
    }
</script>

<script id="fragmentshader" type="x-shader/x-fragment">
    uniform vec3 color;
    varying vec3 vColor;

    void main() {
        float r = 0.0, strength = 0.0;
        // Simple circular particle with soft edge
        r = distance(gl_PointCoord, vec2(0.5, 0.5));
        strength = 1.0 - smoothstep(0.4, 0.5, r);
        
        gl_FragColor = vec4( vColor, strength );
    }
</script>

<script>
    // --- Configuration ---
    const TOTAL_PLANET_PARTICLES = 1500;
    const GALAXY_PARTICLES = 50000; // High count for convincing galaxy
    const BASE_PARTICLE_SIZE = 0.8;

    // --- Planet Data (Including Moons) ---
    const PLANET_DATA = [
        { name: "Sun", color: 0xffa500, orbitR: 0, speed: 0, scale: 3.5, particles: 5000, moons: [] },
        { name: "Earth", color: 0x0077ff, orbitR: 12, speed: 1.0, scale: 0.6, particles: TOTAL_PLANET_PARTICLES, 
            moons: [{ name: "Moon", color: 0xcccccc, orbitR: 2.5, speed: 10.0, scale: 0.2, particles: 500 }] },
        { name: "Mars", color: 0xff3300, orbitR: 18, speed: 0.53, scale: 0.4, particles: TOTAL_PLANET_PARTICLES, 
            moons: [{ name: "Phobos", color: 0x888888, orbitR: 1.5, speed: 15.0, scale: 0.1, particles: 100 }] },
        { name: "Jupiter", color: 0xeebb99, orbitR: 25, speed: 0.08, scale: 2.0, particles: TOTAL_PLANET_PARTICLES * 2,
            moons: [{ name: "Io", color: 0xffaa00, orbitR: 4, speed: 8.0, scale: 0.3, particles: 500 }] },
        { name: "Saturn", color: 0xddeebb, orbitR: 35, speed: 0.03, scale: 1.8, particles: TOTAL_PLANET_PARTICLES * 2,
            moons: [{ name: "Titan", color: 0xbbffbb, orbitR: 6, speed: 5.0, scale: 0.4, particles: 600 }] }
    ];

    // --- State ---
    let handTension = 0.0; // 0 = Solar System, 1 = Galaxy View
    let planets = [];
    let galaxyMesh;

    // --- Three.js Setup ---
    const container = document.getElementById('canvas-container');
    const scene = new THREE.Scene();
    scene.fog = new THREE.FogExp2(0x000000, 0.005); // Deeper fog for better depth

    const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 5000);
    camera.position.set(0, 50, 80);
    camera.lookAt(0, 0, 0);

    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio);
    container.appendChild(renderer.domElement);

    // --- Custom Shader Material ---
    const particleUniforms = {
        size: { value: BASE_PARTICLE_SIZE },
        scale: { value: window.innerHeight / 2 },
        color: { value: new THREE.Color(0xffffff) },
        time: { value: 0.0 }
    };

    const particleMaterial = new THREE.ShaderMaterial({
        uniforms: particleUniforms,
        vertexShader: document.getElementById('vertexshader').textContent,
        fragmentShader: document.getElementById('fragmentshader').textContent,
        blending: THREE.AdditiveBlending,
        depthTest: false,
        transparent: true
    });

    // --- Core Functions ---

    // 1. Particle Cloud Generator (Sphere/Volume)
    function generateParticleCloud(count, radius, colorHex) {
        const geometry = new THREE.BufferGeometry();
        const positions = new Float32Array(count * 3);
        const colors = new Float32Array(count * 3);
        const color = new THREE.Color(colorHex);

        for (let i = 0; i < count; i++) {
            const i3 = i * 3;
            
            // Random point in a sphere
            const r = Math.cbrt(Math.random()) * radius;
            const theta = Math.random() * Math.PI * 2;
            const phi = Math.acos(2 * Math.random() - 1);

            positions[i3] = r * Math.sin(phi) * Math.cos(theta);
            positions[i3 + 1] = r * Math.sin(phi) * Math.sin(theta);
            positions[i3 + 2] = r * Math.cos(phi);
            
            // Assign color
            colors[i3] = color.r;
            colors[i3 + 1] = color.g;
            colors[i3 + 2] = color.b;
        }

        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        geometry.setAttribute('customColor', new THREE.BufferAttribute(colors, 3));

        const mesh = new THREE.Points(geometry, particleMaterial.clone());
        mesh.material.uniforms.color.value.set(colorHex);
        return mesh;
    }

    // 2. Galaxy Generator (Spiral Arms)
    function createGalaxy() {
        const count = GALAXY_PARTICLES;
        const geometry = new THREE.BufferGeometry();
        const positions = new Float32Array(count * 3);
        const colors = new Float32Array(count * 3);
        
        const galaxyRadius = 2000;
        
        for (let i = 0; i < count; i++) {
            const i3 = i * 3;
            
            // Spiral Arm Logic
            const arm = Math.floor(Math.random() * 4); // 4 arms
            const angle = Math.random() * Math.PI * 2;
            let r = Math.pow(Math.random(), 2) * galaxyRadius;
            
            const spiralAngle = angle + (r / galaxyRadius) * 6 * Math.PI + arm * Math.PI / 2;
            
            // Add some thickness/blur
            r += (Math.random() - 0.5) * 50; 
            
            positions[i3] = Math.cos(spiralAngle) * r;
            positions[i3 + 1] = (Math.random() - 0.5) * 100; // Vertical spread
            positions[i3 + 2] = Math.sin(spiralAngle) * r;
            
            // Color variations (blue/white/pink nebula)
            const color = new THREE.Color();
            if (Math.random() > 0.8) color.set(0xff00ff); // Pink
            else if (Math.random() > 0.5) color.set(0x00ffff); // Cyan
            else color.set(0xffffff); // White
            
            colors[i3] = color.r;
            colors[i3 + 1] = color.g;
            colors[i3 + 2] = color.b;
        }

        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        geometry.setAttribute('customColor', new THREE.BufferAttribute(colors, 3));
        
        const galaxyMaterial = particleMaterial.clone();
        galaxyMaterial.uniforms.size.value = 15.0; // Larger points for background
        
        galaxyMesh = new THREE.Points(geometry, galaxyMaterial);
        scene.add(galaxyMesh);
    }
    
    // 3. Solar System Initialization
    function createSolarSystem() {
        planets = [];
        PLANET_DATA.forEach(data => {
            // Main Planet Mesh
            const planetMesh = generateParticleCloud(
                data.particles, 
                data.scale, 
                data.color
            );
            
            // Create a Group to hold the planet and its moons
            const systemGroup = new THREE.Group();
            systemGroup.add(planetMesh); // Planet is at the center of its group
            
            const planetObject = {
                name: data.name,
                mesh: systemGroup, // Use group as the main mesh for orbiting
                core: planetMesh,
                orbitRadius: data.orbitR,
                orbitalSpeed: data.speed,
                rotationSpeed: data.speed * 5,
                startTime: Math.random() * 2 * Math.PI, 
                moons: []
            };

            // Moons
            data.moons.forEach(moonData => {
                const moonMesh = generateParticleCloud(
                    moonData.particles, 
                    moonData.scale, 
                    moonData.color
                );
                
                // Add moon to the planet's systemGroup, not the scene directly
                systemGroup.add(moonMesh); 
                
                planetObject.moons.push({
                    mesh: moonMesh,
                    orbitRadius: moonData.orbitR,
                    orbitalSpeed: moonData.speed,
                    startTime: Math.random() * 2 * Math.PI,
                });
            });
            
            scene.add(systemGroup);
            planets.push(planetObject);
        });
    }

    createSolarSystem();
    createGalaxy();

    // --- Hand Tracking Logic (MediaPipe) ---
    const videoElement = document.getElementById('input-video');
    const hands = new Hands({locateFile: (file) => {
        return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
    }});

    hands.setOptions({
        maxNumHands: 1, 
        modelComplexity: 1,
        minDetectionConfidence: 0.7,
        minTrackingConfidence: 0.5
    });

    hands.onResults(onResults);

    function onResults(results) {
        const handStatus = document.getElementById('hand-status');
        const dot = document.querySelector('.dot');
        const controlBar = document.getElementById('hand-control-bar');

        if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
            document.getElementById('loading').style.display = 'none';
            handStatus.innerText = "Hand Detected";
            dot.style.background = "#00ffff";

            const landmarks = results.multiHandLandmarks[0];
            
            // Distance between Thumb Tip (4) and Pinky Tip (20)
            const thumbTip = landmarks[4];
            const pinkyTip = landmarks[20];
            
            const d = Math.hypot(thumbTip.x - pinkyTip.x, thumbTip.y - pinkyTip.y, thumbTip.z - pinkyTip.z);
            
            // Map distance to openness (0 to 1)
            let openness = (d - 0.05) / (0.4 - 0.05); 
            openness = Math.max(0, Math.min(1, openness)); 
            
            handTension = THREE.MathUtils.lerp(handTension, openness, 0.1);

        } else {
            handStatus.innerText = "Show hand to control";
            dot.style.background = "#ff4444";
            // Slowly revert to neutral view (Solar System)
            handTension = THREE.MathUtils.lerp(handTension, 0.0, 0.05);
        }
        
        controlBar.style.width = `${handTension * 100}%`;
    }

    // Camera Setup
    const cam = new Camera(videoElement, {
        onFrame: async () => {
            await hands.send({image: videoElement});
        },
        width: 640,
        height: 480
    });
    cam.start();

    // --- Animation Loop ---
    const clock = new THREE.Clock();

    function animate() {
        requestAnimationFrame(animate);

        const time = clock.getElapsedTime();
        
        // 1. Hand Control Mapping: HYBRID ZOOM/SPEED
        
        // Hand Tension (0) -> Solar System View (Near, Slow)
        // Hand Tension (1) -> Galaxy View (Far, Fast)
        
        const orbitSpeedMultiplier = THREE.MathUtils.lerp(0.1, 5.0, handTension);
        const cameraDistance = THREE.MathUtils.lerp(70, 4000, handTension);
        const systemScale = THREE.MathUtils.lerp(1.0, 50.0, handTension * handTension); // Exponential scale up for big jump

        // Update UI Mode
        document.getElementById('mode-display').innerText = handTension < 0.5 ? 
            "Solar System (Contracted)" : "Galaxy View (Expanded)";


        // 2. Animate Planets (Solar System)
        planets.forEach(planet => {
            const group = planet.mesh;
            
            // Orbit Calculation
            const angle = planet.startTime + time * planet.orbitalSpeed * orbitSpeedMultiplier;
            const radius = planet.orbitRadius * systemScale; 
            
            group.position.x = Math.cos(angle) * radius;
            group.position.z = Math.sin(angle) * radius;
            
            // Self Rotation
            planet.core.rotation.y += planet.rotationSpeed * 0.005 * orbitSpeedMultiplier;
            
            // Animate Moons (Relative to Planet)
            planet.moons.forEach(moon => {
                const moonAngle = moon.startTime + time * moon.orbitalSpeed * orbitSpeedMultiplier;
                // Moons use small, fixed orbit radius (not scaled by systemScale)
                moon.mesh.position.x = Math.cos(moonAngle) * moon.orbitRadius;
                moon.mesh.position.z = Math.sin(moonAngle) * moon.orbitRadius;
            });
        });

        // 3. Galaxy Movement
        if (galaxyMesh) {
            // Galaxy rotates slightly in the background
            galaxyMesh.rotation.y = time * 0.01; 
            // Visibility: Galaxy should be faint when zoomed in (handTension < 0.5)
            galaxyMesh.material.opacity = THREE.MathUtils.lerp(0.05, 1.0, handTension);
        }

        // 4. Camera Control
        camera.position.x = Math.sin(time * 0.01) * cameraDistance * 0.05;
        camera.position.z = Math.cos(time * 0.01) * cameraDistance * 0.05;
        
        // Adjust Camera Z-distance
        camera.position.y = THREE.MathUtils.lerp(20, cameraDistance / 4, handTension);
        
        // Smoothly move camera away from center
        camera.position.setLength(cameraDistance); 
        camera.lookAt(0, 0, 0);

        renderer.render(scene, camera);
    }

    animate();

    // Handle Resize
    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });

</script>
</body>
</html>
        for (let i = 0; i < count; i++) {
            const i3 = i * 3;
            
            // Random point in a sphere (for planet volume)
            const r = Math.cbrt(Math.random()) * radius;
            const theta = Math.random() * Math.PI * 2;
            const phi = Math.acos(2 * Math.random() - 1);

            positions[i3] = r * Math.sin(phi) * Math.cos(theta);
            positions[i3 + 1] = r * Math.sin(phi) * Math.sin(theta);
            positions[i3 + 2] = r * Math.cos(phi);
            
            // Color fading based on style
            if (style === 'fire') {
                centerColor.set(0xff4400).lerp(new THREE.Color(0xffffff), Math.random() * 0.5);
            } else if (style === 'nebula') {
                centerColor.set(color).lerp(new THREE.Color(0x00ffff), Math.random() * 0.5);
            }

            colors[i3] = centerColor.r;
            colors[i3 + 1] = centerColor.g;
            colors[i3 + 2] = centerColor.b;
        }

        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

        const material = new THREE.PointsMaterial({
            size: PARTICLE_SIZE,
            vertexColors: true,
            transparent: true,
            opacity: 0.9,
            blending: THREE.AdditiveBlending,
            depthWrite: false
        });

        const points = new THREE.Points(geometry, material);
        return points;
    }

    // --- Solar System Initialization ---
    function createSolarSystem(style) {
        // Clear previous system
        planets.forEach(p => scene.remove(p.mesh));
        planets = [];

        PLANET_DATA.forEach(data => {
            const particleMesh = generateSphereParticles(
                data.particles, 
                data.size, 
                data.color, 
                style
            );
            
            // Orbit visual (optional, can be added with THREE.Line)
            
            const planetObject = {
                name: data.name,
                mesh: particleMesh,
                orbitRadius: data.orbitR,
                orbitalSpeed: data.speed,
                rotationSpeed: data.speed * 5,
                startTime: Math.random() * 2 * Math.PI, // Random start angle
                initialColor: new THREE.Color(data.color)
            };
            
            scene.add(particleMesh);
            planets.push(planetObject);
        });
    }
    
    // Initial system creation
    createSolarSystem(currentStyle);

    // --- Interaction Logic (MediaPipe) ---
    const videoElement = document.getElementById('input-video');
    const hands = new Hands({locateFile: (file) => {
        return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
    }});

    hands.setOptions({
        maxNumHands: 1, // Focusing on single hand for simplicity
        modelComplexity: 1,
        minDetectionConfidence: 0.7,
        minTrackingConfidence: 0.5
    });

    hands.onResults(onResults);

    function onResults(results) {
        const handStatus = document.getElementById('hand-status');
        const dot = document.querySelector('.dot');
        const controlBar = document.getElementById('hand-control-bar');

        if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
            document.getElementById('loading').style.display = 'none';
            handStatus.innerText = "Hand Detected";
            dot.style.background = "#00ff88";

            const landmarks = results.multiHandLandmarks[0];
            
            // Calculate openness (Tension) based on distance between Thumb Tip (4) and Pinky Tip (20)
            const thumbTip = landmarks[4];
            const pinkyTip = landmarks[20];
            
            const d = Math.hypot(thumbTip.x - pinkyTip.x, thumbTip.y - pinkyTip.y, thumbTip.z - pinkyTip.z);
            
            // Simple normalization based on typical min/max distance (0.05 to 0.4)
            let openness = (d - 0.05) / (0.4 - 0.05); 
            openness = Math.max(0, Math.min(1, openness)); // Clamp between 0 (fist) and 1 (open)
            
            // Smoothly update state
            handTension = THREE.MathUtils.lerp(handTension, openness, 0.2);

        } else {
            handStatus.innerText = "Show hand to control";
            dot.style.background = "#ff4444";
            // Slowly revert to neutral speed (0.5) if hands lost
            handTension = THREE.MathUtils.lerp(handTension, 0.5, 0.05);
        }
        
        // Update UI bar
        controlBar.style.width = `${handTension * 100}%`;
    }

    // Camera Setup
    const cam = new Camera(videoElement, {
        onFrame: async () => {
            await hands.send({image: videoElement});
        },
        width: 640,
        height: 480
    });
    cam.start();

    // --- UI Events ---
    document.getElementById('template-select').addEventListener('change', (e) => {
        currentStyle = e.target.value;
        createSolarSystem(currentStyle);
    });

    // --- Animation Loop ---
    const clock = new THREE.Clock();

    function animate() {
        requestAnimationFrame(animate);

        const time = clock.getElapsedTime();
        
        // 1. Hand Control to System Speed and Scale
        
        // Hand Tension (0 to 1) maps to:
        // Closed (0) -> Slow speed (0.1), Zoom In (Scale 0.7)
        // Open (1) -> Fast speed (2.0), Zoom Out (Scale 1.5)
        
        const systemSpeed = THREE.MathUtils.lerp(0.1, 2.0, handTension);
        const systemScale = THREE.MathUtils.lerp(0.7, 1.5, handTension);

        // 2. Animate Planets
        planets.forEach(planet => {
            const mesh = planet.mesh;
            
            // Orbit Position
            const angle = planet.startTime + time * planet.orbitalSpeed * systemSpeed;
            const radius = planet.orbitRadius * planet.orbitRadius * systemScale; // Quadratic scaling helps visual separation
            
            mesh.position.x = Math.cos(angle) * radius;
            mesh.position.z = Math.sin(angle) * radius;
            
            // Planet Rotation (Self)
            mesh.rotation.y += planet.rotationSpeed * 0.01 * systemSpeed;
            
            // Dynamic Color/Scale Feedback (e.g., Sun pulses when tension is high)
            if (planet.name === 'Sun') {
                const material = mesh.material;
                // Brightness/Scale based on hand tension
                const pulse = 1 + Math.sin(time * 5) * 0.05 * handTension;
                mesh.scale.setScalar(pulse); 
                
                material.opacity = THREE.MathUtils.lerp(0.6, 1.0, handTension);
            }
        });

        // Camera control: Slight spin and zoom out
        camera.position.x = Math.sin(time * 0.05) * 60;
        camera.position.z = Math.cos(time * 0.05) * 60;
        
        // Camera distance adjustment based on control
        camera.position.y = THREE.MathUtils.lerp(20, 40, handTension);
        camera.lookAt(0, 0, 0);

        renderer.render(scene, camera);
    }

    animate();

    // Handle Resize
    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });

</script>
</body>
  </html>
  
